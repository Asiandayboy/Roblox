--!strict
--[[ v1.2.0 - 4/1/2025 ]]
local DraggableUI = {
	DEBUG_PRINT_MODE = false
}

local UIS = game:GetService("UserInputService")
local GuiService = game:GetService("GuiService")
local Players = game:GetService("Players")
local player = Players.LocalPlayer::Player
local playerGui = player.PlayerGui


export type Draggable = {
	ID: number,
	--[[
		If BeforeDragStart returns true, the drag will start, else it will not start.
	]]
	BeforeDragStart: (() -> boolean)?,
	OnDragStart: (() -> ())?,
	OnDragMove: ((mousePos: Vector2) -> ())?,
	OnDragEnd: ((mousePos: Vector2, guisAtPos: { GuiObject }, wasDragged: boolean) -> ())?
}

type _Draggable = {
	_instance: GuiObject,
	_mouse1Down: boolean,
	_dragging: boolean,
	_parent: any,
	_size: Vector2,
	_pos: Vector2,
	_zIndex: number,
	_dragParent: ScreenGui,
	_parentSize: UDim2,
	_parentPos: UDim2,
	_moveCon: RBXScriptConnection?,
	_inputBegan: RBXScriptConnection?,
	_inputEnded: RBXScriptConnection?,
	_guiInsetIgnored: boolean,
}


local _objs: { [number]: _Draggable | boolean } = {}


local function disconnectCon(con: RBXScriptConnection?)
	if con and con.Connected then
		con:Disconnect()
	end
end

local function revertToParentProps(_props: _Draggable)
	local guiObj =_props._instance
	guiObj.Parent = _props._parent
	guiObj.Size = _props._parentSize
	guiObj.Position = _props._parentPos
	guiObj.ZIndex -= _props._zIndex
end

local function saveParentProps(_props: _Draggable)
	local guiObj =_props._instance
	_props._size = guiObj.AbsoluteSize
	_props._pos = guiObj.AbsolutePosition
	_props._parent = guiObj.Parent
	_props._parentPos = guiObj.Position
	_props._parentSize = guiObj.Size
	_props._zIndex = guiObj.ZIndex
end


function DraggableUI.new(guiObj: GuiObject): Draggable
	local screenGui = guiObj:FindFirstAncestorWhichIsA("ScreenGui") -- used as the parent to guiObj when dragging 
	if not screenGui then error("Could not find an ancestor screenGui to anchor the draggable object", 0) end
	
	local _props = {
		_instance = guiObj,
		_mouse1Down = false,
		_dragging = false,
		_parent = nil,
		_size = Vector2.zero,
		_pos = Vector2.zero,
		_zIndex = 1,
		_dragParent = screenGui,
		_parentSize = UDim2.new(),
		_parentPos = UDim2.new(),
		_guiInsetIgnored = screenGui.IgnoreGuiInset::boolean
	}::_Draggable
	
	local id
	local vacantSpotFilled = false
	for i,v in ipairs(_objs) do
		if v then continue end
		_objs[i] = _props
		vacantSpotFilled = true
		id = i
		break
	end
	
	if not vacantSpotFilled then
		table.insert(_objs, _props)
		id = #_objs
	end
	
	local props = {
		ID = id
	}::Draggable
	
	if DraggableUI.DEBUG_PRINT_MODE then
		warn("Draggable created; ID =", props.ID)
	end
	
	return props
end

function DraggableUI.IsDragging(draggableObj: Draggable): boolean
	local _props: _Draggable = _objs[draggableObj.ID]::_Draggable
	return _props._dragging
end

function DraggableUI.Enable(draggableObj: Draggable)
	local _props: _Draggable = _objs[draggableObj.ID]::_Draggable
	local guiObj = _props._instance
	
	local canStartDrag = true

	_props._inputBegan = guiObj.InputBegan:Connect(function(input: InputObject)
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			canStartDrag = (draggableObj.BeforeDragStart and draggableObj.BeforeDragStart()) or true
			
			if not canStartDrag then return end
			
			_props._mouse1Down = true
			
			saveParentProps(_props)
			local guiInset = _props._guiInsetIgnored and GuiService:GetGuiInset() or Vector2.zero

			guiObj.Parent = _props._dragParent
			guiObj.Size = UDim2.new(0, _props._size.X, 0, _props._size.Y)
			guiObj.Position = UDim2.new(0, math.ceil(_props._pos.X), 0, _props._pos.Y+guiInset.Y)
			guiObj.ZIndex = 100
			
			local initialMousePos = UIS:GetMouseLocation()
			local offset = _props._pos - initialMousePos + guiInset

			_props._moveCon = UIS.InputChanged:Connect(function(uisInput: InputObject)
				if uisInput.UserInputType == Enum.UserInputType.MouseMovement and _props._mouse1Down then
					if not _props._dragging then
						if draggableObj.OnDragStart then task.spawn(draggableObj.OnDragStart) end
					end
					_props._dragging = true
					local mouse = UIS:GetMouseLocation()
					guiObj.Position = UDim2.new(0, mouse.X + offset.X, 0, mouse.Y + offset.Y)
					if draggableObj.OnDragMove then task.spawn(draggableObj.OnDragMove, mouse) end
				end
			end)
		end
	end)
	
	_props._inputEnded = guiObj.InputEnded:Connect(function(input: InputObject)
		if input.UserInputType == Enum.UserInputType.MouseButton1 then
			if not canStartDrag then return end
			
			_props._mouse1Down = false
			revertToParentProps(_props)
			disconnectCon(_props._moveCon)
			
			local wasDragged = _props._dragging
			_props._dragging = false
			
			if draggableObj.OnDragEnd then 
				local mousePos = UIS:GetMouseLocation()
				local guisAtPos = playerGui:GetGuiObjectsAtPosition(mousePos.X, mousePos.Y - GuiService:GetGuiInset().Y)
				task.spawn(draggableObj.OnDragEnd, mousePos, guisAtPos, wasDragged) 
			end
		end
	end)
end

function DraggableUI.Disable(draggableObj: Draggable)
	local _props: _Draggable = _objs[draggableObj.ID]::_Draggable
	_props._mouse1Down = false
	
	if _props._instance.Parent ~= nil and _props._dragging then
		revertToParentProps(_props)
	end
	disconnectCon(_props._inputBegan)
	disconnectCon(_props._inputEnded)
	disconnectCon(_props._moveCon)
end

function DraggableUI.Destroy(draggableObj: Draggable)
	if _objs[draggableObj.ID] == nil then error("[DragagbleUI]: Attempt to call DraggableUI.Destroy on nil;", 0) end
	
	DraggableUI.Disable(draggableObj)
	_objs[draggableObj.ID] = false
end





return DraggableUI
